/// <reference types="node" />
import { ILiveProc } from "./liveproc";
import { IProc } from "../node/proc";
import { ConnectSocket } from "../socket/connect";
import { Monitor } from "forever-monitor";
import { ChildProcess } from "child_process";
declare module "forever-monitor" {
    interface Monitor {
        child: ChildProcess;
    }
}
export interface ICommitLog {
    topic: string;
    body: object;
}
declare type InlineProcessorFn = (result?: {
    id: string;
    body: object;
} | {
    id: string;
    body: object;
}[], done?: (err: Error | null, newLog?: {
    id: string;
    body: object;
} | {
    id: string;
    body: object;
}[]) => void) => void;
export interface IPipeProcClient {
    pipeProcNode?: Monitor | {};
    connectSocket?: ConnectSocket;
    messageMap: {
        [key: string]: (e: any) => void;
    };
    commit(commitLog: ICommitLog | ICommitLog[]): Promise<string | string[]>;
    spawn(options?: {
        namespace?: string;
        tcp?: {
            host: string;
            port: number;
        };
        tls?: {
            server: {
                key: string;
                cert: string;
                ca: string;
            };
            client: {
                key: string;
                cert: string;
                ca: string;
            };
        };
        socket?: string;
        memory?: boolean;
        location?: string;
        workers?: number;
        workerConcurrency?: number;
        workerRestartAfter?: number;
        gc?: {
            minPruneTime?: number;
            interval?: number;
        } | boolean;
    }): Promise<string>;
    connect(options?: {
        namespace?: string;
        tcp?: {
            host: string;
            port: number;
        };
        tls?: {
            key: string;
            cert: string;
            ca: string;
        } | false;
        socket?: string;
        isWorker?: boolean;
        timeout?: number;
    }): Promise<string>;
    shutdown(): Promise<string>;
    range(topic: string, options?: {
        start?: string;
        end?: string;
        limit?: number;
        exclusive?: boolean;
    }): Promise<{
        id: string;
        body: object;
    }[]>;
    revrange(topic: string, options?: {
        start?: string;
        end?: string;
        limit?: number;
        exclusive?: boolean;
    }): Promise<{
        id: string;
        body: object;
    }[]>;
    length(topic: string): Promise<number>;
    proc(topic: string, options: {
        name: string;
        offset: string;
        count?: number;
        maxReclaims?: number;
        reclaimTimeout?: number;
        onMaxReclaimsReached?: string;
    }): Promise<null | {
        id: string;
        body: object;
    } | {
        id: string;
        body: object;
    }[]>;
    availableProc(procList: {
        name: string;
        topic: string;
        offset: string;
        count?: number;
        maxReclaims?: number;
        reclaimTimeout?: number;
        onMaxReclaimsReached?: string;
    }[]): Promise<undefined | {
        procName?: string;
        log?: {
            id: string;
            body: object;
        } | {
            id: string;
            body: object;
        }[];
    }>;
    systemProc(options: {
        name: string;
        offset: string;
        count?: number;
        maxReclaims?: number;
        reclaimTimeout?: number;
        onMaxReclaimsReached?: string;
        from: string | string[];
        to?: string | string[];
        processor: string | InlineProcessorFn;
    }): Promise<IProc | IProc[]>;
    ack(procName: string): Promise<string>;
    ackCommit(procName: string, commitLog: ICommitLog | ICommitLog[]): Promise<{
        ackedLogId: string;
        id: string | string[];
    }>;
    inspectProc(procName: string): Promise<IProc>;
    destroyProc(procName: string): Promise<IProc>;
    disableProc(procName: string): Promise<IProc>;
    resumeProc(procName: string): Promise<IProc>;
    reclaimProc(procName: string): Promise<string>;
    liveProc(options: {
        topic: string;
        mode: "live" | "all";
        count?: number;
    }): ILiveProc;
    waitForProcs(procs?: string | string[]): Promise<void>;
}
export declare function PipeProc(): IPipeProcClient;
export {};
