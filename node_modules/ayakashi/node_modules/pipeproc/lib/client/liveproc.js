"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const actions_1 = require("./actions");
const uuid_1 = require("uuid");
const backoff_1 = require("backoff");
const async_1 = require("async");
const debug_1 = __importDefault(require("debug"));
const d = debug_1.default("pipeproc:client:liveproc");
function createLiveProc(client, options) {
    let processing = false;
    const name = `liveproc-${uuid_1.v4()}`;
    d(`starting liveProc: ${name}`);
    let stop = false;
    const lp = {
        changes: function (cb) {
            //start loop that calls changesFn and also locks by processing flag
            const strategy = new backoff_1.ExponentialStrategy({
                randomisationFactor: 0.5,
                initialDelay: 10,
                maxDelay: 3000,
                factor: 2
            });
            async_1.forever(function (next) {
                if (stop)
                    return next(new Error("stop"));
                if (processing)
                    return setTimeout(next, strategy.next());
                processing = true;
                return getLog(function (err, result) {
                    processing = false;
                    if (err) {
                        const nextCb = function () {
                            setTimeout(next, strategy.next());
                        };
                        const cbResult = cb.call(lp, err, null, nextCb);
                        if (cbResult instanceof Promise) {
                            cbResult.then(function () {
                                nextCb();
                            });
                        }
                    }
                    else if (result) {
                        const nextCb = function () {
                            strategy.reset();
                            setImmediate(next);
                        };
                        const cbResult = cb.call(lp, null, result, nextCb);
                        if (cbResult instanceof Promise) {
                            cbResult.then(function () {
                                nextCb();
                            });
                        }
                    }
                    else {
                        setTimeout(next, strategy.next());
                    }
                });
            }, function () { });
            return lp;
        },
        inspect: function () {
            return new Promise(function (resolve, reject) {
                actions_1.inspectProc(client, name, function (err, myProc) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(myProc);
                    }
                });
            });
        },
        destroy: function () {
            return new Promise(function (resolve, reject) {
                actions_1.destroyProc(client, name, function (err, myProc) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        processing = false;
                        resolve(myProc);
                    }
                });
            });
        },
        disable: function () {
            return new Promise(function (resolve, reject) {
                actions_1.disableProc(client, name, function (err, myProc) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        processing = false;
                        resolve(myProc);
                    }
                });
            });
        },
        resume: function () {
            return new Promise(function (resolve, reject) {
                actions_1.resumeProc(client, name, function (err, myProc) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        processing = false;
                        resolve(myProc);
                    }
                });
            });
        },
        reclaim: function () {
            return new Promise(function (resolve, reject) {
                actions_1.reclaimProc(client, name, function (err, lastClaimedRange) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        processing = false;
                        resolve(lastClaimedRange);
                    }
                });
            });
        },
        ack: function () {
            return new Promise(function (resolve, reject) {
                actions_1.ack(client, name, function (err, logId) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        processing = false;
                        resolve(logId);
                    }
                });
            });
        },
        ackCommit: function (commitLog) {
            return new Promise(function (resolve, reject) {
                actions_1.ackCommit(client, name, commitLog, function (err, result) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        processing = false;
                        resolve(result);
                    }
                });
            });
        },
        cancel: function () {
            d(`stopping liveProc: ${name}`);
            return this.disable().then(function () {
                stop = true;
            });
        }
    };
    function getLog(cb) {
        actions_1.proc(client, options.topic, {
            name: name,
            offset: options.mode === "live" ? "$>" : ">",
            count: options.count,
            onMaxReclaimsReached: "continue"
        }, function (err, log) {
            cb(err || null, log);
        });
    }
    return lp;
}
exports.createLiveProc = createLiveProc;
