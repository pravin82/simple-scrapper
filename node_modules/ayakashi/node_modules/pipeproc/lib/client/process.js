"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const messages_1 = require("../common/messages");
const os_1 = require("os");
const fs_1 = require("fs");
const connect_1 = require("../socket/connect");
const forever_monitor_1 = require("forever-monitor");
const path_1 = require("path");
const d = debug_1.default("pipeproc:client");
function spawn(client, options, callback) {
    if (client.pipeProcNode)
        return callback(null, "node_already_active");
    d("spawning node...");
    client.pipeProcNode = new forever_monitor_1.Monitor(path_1.join(__dirname, "..", "node", "pipeProc.js"), {
        //@ts-ignore
        fork: true,
        watch: false,
        spawnWith: { detached: true },
        args: ["--color"],
        max: 3
    });
    client.pipeProcNode.start();
    let connectionAddress;
    if (options.address) {
        connectionAddress = options.address;
    }
    else if (options.tcp) {
        connectionAddress = `tcp://${options.tcp.host}:${options.tcp.port}`;
    }
    else {
        connectionAddress = `ipc://${os_1.tmpdir()}/pipeproc.${options.namespace}`;
    }
    function spawnNode() {
        const initIPCMessage = messages_1.prepareMessage({ type: "init_ipc", data: { address: connectionAddress, tls: options.tls } });
        const ipcEstablishedListener = function (e) {
            if ((e.type !== "ipc_established") || e.msgKey !== initIPCMessage.msgKey)
                return;
            d("internal IPC enabled");
            if (e.errStatus) {
                return callback(new Error(e.errStatus));
            }
            try {
                if (options.tls) {
                    options.tls.client.ca = fs_1.readFileSync(options.tls.client.ca, "utf8");
                    options.tls.client.key = fs_1.readFileSync(options.tls.client.key, "utf8");
                    options.tls.client.cert = fs_1.readFileSync(options.tls.client.cert, "utf8");
                }
            }
            catch (e) {
                return callback(e);
            }
            client.pipeProcNode.child.removeListener("message", ipcEstablishedListener);
            connect_1.connect(connectionAddress, { tls: options.tls && options.tls.client }, function (err, connectSocket) {
                if (err) {
                    return callback(err);
                }
                if (!connectSocket) {
                    return callback(new Error("Failed to create socket"));
                }
                client.connectSocket = connectSocket;
                if (options.address) {
                    d("using connection address:", options.address);
                }
                else if (options.tcp) {
                    d("tcp connection established on host:", options.tcp.host, "and port:", options.tcp.port);
                }
                else {
                    d("ipc established under namespace:", options.namespace);
                }
                //messageMap listener init
                client.connectSocket.onMessage(function (message) {
                    if (typeof client.messageMap[message.msgKey] === "function") {
                        client.messageMap[message.msgKey](message);
                    }
                    delete client.messageMap[message.msgKey];
                });
                const ipcd = debug_1.default("pipeproc:ipc:client");
                client.connectSocket.onError(function (ipcError) {
                    ipcd("client IPC error:", ipcError);
                });
                const systemInitMessage = messages_1.prepareMessage({ type: "system_init", data: { options: options } });
                client.messageMap[systemInitMessage.msgKey] = function (systemInitReply) {
                    if (systemInitReply.type === "system_ready") {
                        callback(null, "spawned_and_connected");
                    }
                    else if (systemInitReply.type === "system_ready_error") {
                        callback(new Error(e.errStatus));
                    }
                };
                d("sending system_init message");
                sendMessageToNode(client, systemInitMessage);
            });
        };
        client.pipeProcNode.child.on("message", ipcEstablishedListener);
        client.pipeProcNode.child.send(initIPCMessage);
    }
    client.pipeProcNode.on("restart", spawnNode);
    spawnNode();
}
exports.spawn = spawn;
function connect(client, options, callback) {
    if (client.connectSocket)
        return callback(null, "already_connected");
    if (!client.pipeProcNode && options.isWorker) {
        client.pipeProcNode = process;
    }
    else if (!client.pipeProcNode) {
        client.pipeProcNode = {};
    }
    let connectionAddress;
    if (options.address) {
        connectionAddress = options.address;
    }
    else if (options.tcp) {
        connectionAddress = `tcp://${options.tcp.host}:${options.tcp.port}`;
    }
    else {
        connectionAddress = `ipc://${os_1.tmpdir()}/pipeproc.${options.namespace}`;
    }
    try {
        if (options.tls) {
            options.tls.ca = fs_1.readFileSync(options.tls.ca, "utf8");
            options.tls.key = fs_1.readFileSync(options.tls.key, "utf8");
            options.tls.cert = fs_1.readFileSync(options.tls.cert, "utf8");
        }
    }
    catch (e) {
        return callback(e);
    }
    connect_1.connect(connectionAddress, { tls: options.tls }, function (err, connectSocket) {
        if (err) {
            return callback(err);
        }
        if (!connectSocket) {
            return callback(new Error("Failed to create socket"));
        }
        client.connectSocket = connectSocket;
        if (options.address) {
            d("using connection address:", options.address);
        }
        else if (options.tcp) {
            d("tcp connection established on host:", options.tcp.host, "and port:", options.tcp.port);
        }
        else {
            d("ipc established under namespace:", options.namespace);
        }
        //messageMap listener init
        client.connectSocket.onMessage(function (message) {
            if (typeof client.messageMap[message.msgKey] === "function") {
                client.messageMap[message.msgKey](message);
            }
            delete client.messageMap[message.msgKey];
        });
        if (options.isWorker) {
            const ipcd = debug_1.default("pipeproc:ipc:worker");
            client.connectSocket.onError(function (ipcErr) {
                ipcd("client IPC error:", ipcErr);
            });
        }
        else {
            const ipcd = debug_1.default("pipeproc:ipc:client");
            client.connectSocket.onError(function (ipcErr) {
                ipcd("client IPC error:", ipcErr);
            });
        }
        const pingMessage = messages_1.prepareMessage({ type: "ping", data: {} });
        let gotPong = false;
        setTimeout(function () {
            if (!gotPong) {
                callback(new Error("connection timed-out"));
            }
        }, options.timeout);
        client.messageMap[pingMessage.msgKey] = function (e) {
            if (e.type === "pong") {
                gotPong = true;
                callback(null, "connected");
            }
        };
        d("sending ping message");
        sendMessageToNode(client, pingMessage);
    });
}
exports.connect = connect;
function shutdown(client, callback) {
    if (client.connectSocket) {
        client.connectSocket.close();
    }
    if (client.pipeProcNode instanceof forever_monitor_1.Monitor) {
        d("closing node...");
        const shutDownMessage = messages_1.prepareMessage({ type: "system_shutdown" });
        const systemClosedListener = function (e) {
            if (e.msgKey !== shutDownMessage.msgKey)
                return;
            client.pipeProcNode.child.removeListener("message", systemClosedListener);
            client.pipeProcNode.stop();
            delete client.pipeProcNode;
            delete client.connectSocket;
            if (e.type === "system_closed") {
                d("node closed");
                callback(null, "closed");
            }
            else if (e.type === "system_closed_error") {
                callback(new Error(e.errStatus || "uknown_error"));
            }
        };
        client.pipeProcNode.child.on("message", systemClosedListener);
        client.pipeProcNode.child.send(shutDownMessage);
    }
    else if (client.pipeProcNode) {
        d("disconnected");
        delete client.pipeProcNode;
        delete client.connectSocket;
        callback(null, "disconnected");
    }
    else {
        return callback(new Error("no_active_node"));
    }
}
exports.shutdown = shutdown;
function sendMessageToNode(client, msg, callback) {
    if (!client.pipeProcNode) {
        if (typeof callback === "function") {
            callback(new Error("no_active_node"));
        }
        return;
    }
    if (!client.connectSocket) {
        if (typeof callback === "function") {
            callback(new Error("no_active_ipc_channel"));
        }
        return;
    }
    client.connectSocket.send(msg, function () {
        if (typeof callback === "function")
            callback();
    });
}
exports.sendMessageToNode = sendMessageToNode;
