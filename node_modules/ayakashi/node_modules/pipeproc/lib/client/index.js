"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
process.env.DEBUG_COLORS = "true";
const process_1 = require("./process");
const actions_1 = require("./actions");
const liveproc_1 = require("./liveproc");
const path_1 = require("path");
const fs_1 = require("fs");
//tslint:disable function-name
function PipeProc() {
    //tslint:enable function-name
    const pipeProcClient = {
        messageMap: {},
        spawn: function (options) {
            let namespace = "default";
            if (options && options.namespace && typeof options.namespace === "string") {
                namespace = options.namespace;
            }
            let address = "";
            if (options && options.socket && typeof options.socket === "string") {
                address = options.socket;
            }
            if (options && options.tcp) {
                if (!options.tcp.host || !options.tcp.port) {
                    return Promise.reject(new Error("tcp connection needs a host and a port"));
                }
            }
            let workers;
            if (options && typeof options.workers === "number" && options.workers >= 0) {
                workers = options.workers;
            }
            else {
                workers = 1;
            }
            let workerConcurrency;
            if (options && typeof options.workerConcurrency === "number" && options.workerConcurrency >= 1) {
                workerConcurrency = options.workerConcurrency;
            }
            else {
                workerConcurrency = 1;
            }
            let workerRestartAfter;
            if (options && typeof options.workerRestartAfter === "number" && options.workerRestartAfter >= 0) {
                workerRestartAfter = options.workerRestartAfter;
            }
            else {
                workerRestartAfter = 0;
            }
            let tls;
            if (options && options.tls) {
                if (!options.tls.server || !options.tls.client) {
                    return Promise.reject(new Error("tls options require a server and client configuration"));
                }
                if (!fs_1.existsSync(options.tls.server.ca)) {
                    return Promise.reject(new Error("tls options require a server ca"));
                }
                if (!fs_1.existsSync(options.tls.server.cert)) {
                    return Promise.reject(new Error("tls options require a server cert"));
                }
                if (!fs_1.existsSync(options.tls.server.key)) {
                    return Promise.reject(new Error("tls options require a server key"));
                }
                if (!fs_1.existsSync(options.tls.client.ca)) {
                    return Promise.reject(new Error("tls options require a client ca"));
                }
                if (!fs_1.existsSync(options.tls.client.cert)) {
                    return Promise.reject(new Error("tls options require a client cert"));
                }
                if (!fs_1.existsSync(options.tls.client.key)) {
                    return Promise.reject(new Error("tls options require a client key"));
                }
                tls = {
                    server: {
                        ca: path_1.resolve(options.tls.server.ca),
                        cert: path_1.resolve(options.tls.server.cert),
                        key: path_1.resolve(options.tls.server.key)
                    },
                    client: {
                        ca: path_1.resolve(options.tls.client.ca),
                        cert: path_1.resolve(options.tls.client.cert),
                        key: path_1.resolve(options.tls.client.key)
                    }
                };
            }
            else {
                tls = false;
            }
            return new Promise(function (resolve, reject) {
                process_1.spawn(pipeProcClient, {
                    address: address,
                    namespace: namespace,
                    tcp: (options && options.tcp) || false,
                    memory: (options && options.memory) || false,
                    location: (options && options.location) || "./pipeproc_data",
                    workers: workers,
                    workerConcurrency: workerConcurrency,
                    workerRestartAfter: workerRestartAfter,
                    gc: (options && options.gc) || undefined,
                    tls: tls
                }, function (err, status) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(status);
                    }
                });
            });
        },
        connect: function (options) {
            let namespace = "default";
            if (options && options.namespace && typeof options.namespace === "string") {
                namespace = options.namespace;
            }
            let address = "";
            if (options && options.socket && typeof options.socket === "string") {
                address = options.socket;
            }
            if (options && options.tcp) {
                if (!options.tcp.host || !options.tcp.port) {
                    return Promise.reject(new Error("tcp connection needs a host and a port"));
                }
            }
            let tls;
            if (options && options.tls) {
                if (!fs_1.existsSync(options.tls.ca)) {
                    return Promise.reject(new Error("tls connect options require a client ca"));
                }
                if (!fs_1.existsSync(options.tls.cert)) {
                    return Promise.reject(new Error("tls connect options require a client cert"));
                }
                if (!fs_1.existsSync(options.tls.key)) {
                    return Promise.reject(new Error("tls connect options require a client key"));
                }
                tls = {
                    ca: path_1.resolve(options.tls.ca),
                    cert: path_1.resolve(options.tls.cert),
                    key: path_1.resolve(options.tls.key)
                };
            }
            else {
                tls = false;
            }
            return new Promise(function (resolve, reject) {
                process_1.connect(pipeProcClient, {
                    address: address,
                    namespace: namespace,
                    tcp: (options && options.tcp) || false,
                    isWorker: (options && options.isWorker) || false,
                    tls: tls,
                    timeout: (options && options.timeout) || 1000
                }, function (err, status) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(status);
                    }
                });
            });
        },
        shutdown: function () {
            return new Promise(function (resolve, reject) {
                process_1.shutdown(pipeProcClient, function (err, status) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(status);
                    }
                });
            });
        },
        range: function (topic, options) {
            return new Promise(function (resolve, reject) {
                actions_1.range(pipeProcClient, topic, {
                    start: (options && options.start) || "",
                    end: (options && options.end) || "",
                    limit: (options && options.limit) || -1,
                    exclusive: (options && options.exclusive) || false,
                    reverse: false
                }, function (err, results) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(results);
                    }
                });
            });
        },
        revrange: function (topic, options) {
            return new Promise(function (resolve, reject) {
                actions_1.range(pipeProcClient, topic, {
                    start: (options && options.start) || "",
                    end: (options && options.end) || "",
                    limit: (options && options.limit) || -1,
                    exclusive: (options && options.exclusive) || false,
                    reverse: true
                }, function (err, results) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(results);
                    }
                });
            });
        },
        length: function (topic) {
            return new Promise(function (resolve, reject) {
                actions_1.range(pipeProcClient, topic, {
                    start: "",
                    end: "",
                    limit: 1,
                    exclusive: false,
                    reverse: true
                }, function (err, results) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        if (results && results[0]) {
                            const l = parseInt(results[0].id.split("-")[1]) + 1;
                            resolve(l);
                        }
                        else {
                            resolve(0);
                        }
                    }
                });
            });
        },
        commit: function (commitLog) {
            return new Promise(function (resolve, reject) {
                actions_1.commit(pipeProcClient, commitLog, function (err, logId) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(logId);
                    }
                });
            });
        },
        proc: function (topic, options) {
            return new Promise(function (resolve, reject) {
                actions_1.proc(pipeProcClient, topic, options, function (err, result) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(result);
                    }
                });
            });
        },
        availableProc: function (procList) {
            return new Promise(function (resolve, reject) {
                actions_1.availableProc(pipeProcClient, procList, function (err, result) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(result);
                    }
                });
            });
        },
        systemProc: function (options) {
            return new Promise(function (resolve, reject) {
                actions_1.systemProc(pipeProcClient, options, function (err, myProc) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(myProc);
                    }
                });
            });
        },
        ack: function (procName) {
            return new Promise(function (resolve, reject) {
                actions_1.ack(pipeProcClient, procName, function (err, logId) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(logId);
                    }
                });
            });
        },
        ackCommit: function (procName, commitLog) {
            return new Promise(function (resolve, reject) {
                actions_1.ackCommit(pipeProcClient, procName, commitLog, function (err, results) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(results);
                    }
                });
            });
        },
        inspectProc: function (procName) {
            return new Promise(function (resolve, reject) {
                actions_1.inspectProc(pipeProcClient, procName, function (err, myProc) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(myProc);
                    }
                });
            });
        },
        destroyProc: function (procName) {
            return new Promise(function (resolve, reject) {
                actions_1.destroyProc(pipeProcClient, procName, function (err, myProc) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(myProc);
                    }
                });
            });
        },
        disableProc: function (procName) {
            return new Promise(function (resolve, reject) {
                actions_1.disableProc(pipeProcClient, procName, function (err, myProc) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(myProc);
                    }
                });
            });
        },
        resumeProc: function (procName) {
            return new Promise(function (resolve, reject) {
                actions_1.resumeProc(pipeProcClient, procName, function (err, myProc) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(myProc);
                    }
                });
            });
        },
        reclaimProc: function (procName) {
            return new Promise(function (resolve, reject) {
                actions_1.reclaimProc(pipeProcClient, procName, function (err, lastClaimedRange) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(lastClaimedRange);
                    }
                });
            });
        },
        liveProc: function (options) {
            return liveproc_1.createLiveProc(pipeProcClient, options);
        },
        waitForProcs: function (procs) {
            var procFilter;
            if (Array.isArray(procs)) {
                procFilter = procs;
            }
            else if (typeof procs === "string") {
                procFilter = [procs];
            }
            else {
                procFilter = [];
            }
            return new Promise(function (resolve, reject) {
                actions_1.waitForProcs(pipeProcClient, procFilter, function (err) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            });
        }
    };
    return pipeProcClient;
}
exports.PipeProc = PipeProc;
