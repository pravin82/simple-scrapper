"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = require("net");
const tls_1 = require("tls");
const send_1 = require("./send");
const xpipe_1 = require("./xpipe");
const debug_1 = __importDefault(require("debug"));
const d = debug_1.default("pipeproc:socket:connect");
function connect(address, options, callback) {
    //tslint:disable no-any
    const messageListeners = [];
    //tslint:enable no-any
    const errorListeners = [];
    let socket;
    if (options.tls) {
        if (address.includes("tcp://")) {
            const parts = address.replace("tcp://", "").split(":");
            socket = tls_1.connect({
                port: parseInt(parts[1]),
                host: parts[0],
                ca: options.tls.ca,
                key: options.tls.key,
                cert: options.tls.cert
            });
        }
        else {
            return callback(new Error(`Invalid connection address: ${address}`));
        }
    }
    else {
        if (address.includes("ipc://")) {
            const socketPath = address.replace("ipc://", "");
            socket = net_1.createConnection(xpipe_1.xpipe(socketPath));
        }
        else if (address.includes("tcp://")) {
            const parts = address.replace("tcp://", "").split(":");
            socket = net_1.createConnection({
                port: parseInt(parts[1]),
                host: parts[0]
            });
        }
        else {
            return callback(new Error(`Invalid connection address: ${address}`));
        }
    }
    const connectSocket = {
        onError: function (listener) {
            errorListeners.push(listener);
        },
        onMessage: function (listener) {
            messageListeners.push(listener);
        },
        close: function () {
            socket.end();
        },
        send: send_1.getSender(socket)
    };
    let cbCalled = false;
    socket.once(options.tls ? "secureConnect" : "connect", function () {
        socket.setNoDelay(true);
        socket.setEncoding("utf8");
        if (!cbCalled) {
            cbCalled = true;
            callback(null, connectSocket);
        }
    });
    socket.on("error", function (err) {
        d("Socket error:", err);
        if (!cbCalled) {
            cbCalled = true;
            return callback(err);
        }
        errorListeners.forEach(function (listener) {
            listener(err);
        });
    });
    let buffer = "";
    socket.on("data", function (chunk) {
        const data = buffer + chunk;
        const messages = data.split("%EOM%");
        buffer = messages.pop() || "";
        messages.forEach(function (msg) {
            let parsedData;
            try {
                parsedData = JSON.parse(msg);
            }
            catch (e) {
                d("Socket data parsing error:", e, msg);
                return;
            }
            messageListeners.forEach(function (listener) {
                listener(parsedData);
            });
        });
    });
}
exports.connect = connect;
