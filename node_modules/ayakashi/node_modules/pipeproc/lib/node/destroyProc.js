"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const transaction_1 = require("./transaction");
const async_1 = require("async");
const d = debug_1.default("pipeproc:node");
function destroyProc(db, activeProcs, procName, callback) {
    const myProc = activeProcs.find(p => p.name === procName);
    if (!myProc) {
        return callback(new Error("invalid_proc"));
    }
    d("deleting proc:", procName);
    const iterator = db.iterator({
        gte: `~~system~~#proc#${myProc.topic}#${myProc.name}#`,
        values: false,
        keyAsBuffer: false,
        limit: -1
    });
    const keys = [];
    async_1.forever(function (next) {
        iterator.next(function (err, key) {
            if (err)
                return next(err);
            if (!key)
                return next(new Error("stop"));
            keys.push(key);
            async_1.setImmediate(next);
        });
    }, function (status) {
        if (!status || status.message === "stop") {
            iterator.end(function (iteratorEndErr) {
                if (iteratorEndErr)
                    return callback(iteratorEndErr);
                const tx = transaction_1.transaction(db);
                tx.add(keys.map(key => {
                    return { key: key.toString() };
                }));
                tx.commitDelete(function (err) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        const procIndex = activeProcs.indexOf(myProc);
                        activeProcs.splice(procIndex, 1);
                        callback(null, myProc);
                    }
                });
            });
        }
        else {
            callback(new Error(status.message));
        }
    });
}
exports.destroyProc = destroyProc;
