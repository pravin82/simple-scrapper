"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const async_1 = require("async");
const tones_1 = require("./tones");
const d = debug_1.default("pipeproc:node");
function restoreState(db, activeTopics, systemState, activeProcs, activeSystemProcs, inMemory = false, callback) {
    async_1.series([
        function (cb) {
            d("opening database...");
            db.open(cb);
        },
        function (cb) {
            if (inMemory)
                return cb();
            d("restoring active topics...");
            const iteratorOptions = {
                gte: "~~system~~#activeTopics#",
                keyAsBuffer: false,
                valueAsBuffer: false
            };
            const iterator = db.iterator(iteratorOptions);
            async_1.forever(function (next) {
                iterator.next(function (err, key, value) {
                    if (err)
                        return next(err);
                    if (!key)
                        return next(new Error("stop"));
                    const topic = key.toString().split("~~system~~#activeTopics#")[1];
                    if (key.indexOf("~~system~~#activeTopics#") > -1 && topic) {
                        activeTopics[topic] = {
                            currentTone: tones_1.ZERO_TONE,
                            createdAt: parseInt(value.toString())
                        };
                    }
                    next();
                });
            }, function (status) {
                if (!status || status.message === "stop") {
                    iterator.end(cb);
                }
                else {
                    iterator.end(function () {
                        cb(status);
                    });
                }
            });
        },
        function (cb) {
            if (inMemory)
                return cb();
            d("restoring topic tones...");
            const iteratorOptions = {
                gte: "~~system~~#currentTone#",
                keyAsBuffer: false,
                valueAsBuffer: false
            };
            const iterator = db.iterator(iteratorOptions);
            async_1.forever(function (next) {
                iterator.next(function (err, key, value) {
                    if (err)
                        return next(err);
                    if (!key)
                        return next(new Error("stop"));
                    const topic = key.toString().split("~~system~~#currentTone#")[1];
                    if (key.indexOf("~~system~~#currentTone#") > -1 && topic) {
                        activeTopics[topic].currentTone = value.toString();
                    }
                    next();
                });
            }, function (status) {
                if (!status || status.message === "stop") {
                    iterator.end(cb);
                }
                else {
                    iterator.end(function () {
                        cb(status);
                    });
                }
            });
        },
        function (cb) {
            if (inMemory)
                return cb();
            d("restoring active procs...");
            const iteratorOptions = {
                gte: "~~system~~#proc#",
                keyAsBuffer: false,
                valueAsBuffer: false
            };
            const iterator = db.iterator(iteratorOptions);
            async_1.forever(function (next) {
                iterator.next(function (err, key, value) {
                    if (err)
                        return next(err);
                    if (!key)
                        return next(new Error("stop"));
                    if (key.indexOf("~~system~~#proc#") === -1)
                        return next();
                    const unprefixed = key.toString().split("~~system~~#proc#")[1];
                    const topic = unprefixed.split("#")[0];
                    const procName = unprefixed.split("#")[1];
                    const procProperty = unprefixed.split("#")[2];
                    const myProc = activeProcs.find(p => p.name === procName);
                    let newProc;
                    if (myProc) {
                        myProc[procProperty] = formatProcProperty(procProperty, value.toString());
                    }
                    else {
                        newProc = {
                            name: procName,
                            topic: topic,
                            offset: ">",
                            createdAt: Date.now(),
                            lastClaimedAt: 0,
                            lastAckedAt: 0,
                            lastClaimedRange: "",
                            lastAckedRange: "",
                            previousClaimedRange: "",
                            status: "active",
                            reclaims: 0,
                            maxReclaims: 10,
                            reclaimTimeout: 10000,
                            onMaxReclaimsReached: "disable"
                        };
                        newProc[procProperty] = formatProcProperty(procProperty, value.toString());
                        activeProcs.push(newProc);
                    }
                    next();
                });
            }, function (status) {
                if (!status || status.message === "stop") {
                    iterator.end(cb);
                }
                else {
                    iterator.end(function () {
                        cb(status);
                    });
                }
            });
        },
        function (cb) {
            if (inMemory)
                return cb();
            d("restoring active system procs...");
            const iteratorOptions = {
                gte: "~~system~~#systemProc#",
                keyAsBuffer: false,
                valueAsBuffer: false
            };
            const iterator = db.iterator(iteratorOptions);
            async_1.forever(function (next) {
                iterator.next(function (err, key, value) {
                    if (err)
                        return next(err);
                    if (!key)
                        return next(new Error("stop"));
                    if (key.indexOf("~~system~~#systemProc#") === -1)
                        return next();
                    const unprefixed = key.toString().split("~~system~~#systemProc#")[1];
                    const topic = unprefixed.split("#")[0];
                    const procName = unprefixed.split("#")[1];
                    const procProperty = unprefixed.split("#")[2];
                    const mySystemProc = activeSystemProcs.find(p => p.name === procName);
                    let newSystemProc;
                    if (mySystemProc) {
                        mySystemProc[procProperty] = value;
                    }
                    else {
                        newSystemProc = {
                            name: procName,
                            topic: topic,
                            to: ""
                        };
                        newSystemProc[procProperty] = value;
                        activeSystemProcs.push(newSystemProc);
                    }
                    next();
                });
            }, function (status) {
                if (!status || status.message === "stop") {
                    iterator.end(cb);
                }
                else {
                    iterator.end(function () {
                        cb(status);
                    });
                }
            });
        },
        function (cb) {
            if (!inMemory) {
                d("restored topics:", Object.keys(activeTopics));
                d("restored procs:", activeProcs.map(p => p.name));
                d("restored systemProcs:", activeSystemProcs.map(p => p.name));
            }
            systemState.active = true;
            cb();
        }
    ], function (err) {
        if (err) {
            callback(err);
        }
        else {
            callback(null);
        }
    });
}
exports.restoreState = restoreState;
function formatProcProperty(propertyName, propertyValue) {
    if ([
        "createdAt",
        "lastClaimedAt",
        "lastAckedAt",
        "reclaims",
        "maxReclaims",
        "reclaimTimeout"
    ].indexOf(propertyName) > -1) {
        return parseInt(propertyValue);
    }
    else {
        return propertyValue;
    }
}
