"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const messages_1 = require("../common/messages");
const fs_1 = require("fs");
const bind_1 = require("../socket/bind");
const d = debug_1.default("pipeproc:node");
function sendMessageToWorker(msg, worker, cb) {
    if (worker.process && typeof worker.process.send === "function") {
        try {
            worker.process.send(msg, cb);
        }
        catch (e) {
            d(e);
        }
    }
}
exports.sendMessageToWorker = sendMessageToWorker;
function registerMessage(registry, newMessage) {
    if (!registry[newMessage.messageType]) {
        registry[newMessage.messageType] = newMessage;
    }
}
exports.registerMessage = registerMessage;
function initializeMessages(writeBuffer, registry, address, tls, callback) {
    try {
        if (tls) {
            tls.ca = fs_1.readFileSync(tls.ca, "utf8");
            tls.key = fs_1.readFileSync(tls.key, "utf8");
            tls.cert = fs_1.readFileSync(tls.cert, "utf8");
        }
    }
    catch (e) {
        return callback(e);
    }
    bind_1.bind(address, { tls: tls }, function (err, server) {
        if (err) {
            return callback(err);
        }
        if (!server) {
            return callback(new Error("failed_to_create_server"));
        }
        server.onMessage(function (msg, binder) {
            if (!registry[msg.type])
                return;
            if (registry[msg.type].writeOp) {
                writeBuffer.push(function (cb) {
                    registry[msg.type].listener(msg.data, function (errStatus, reply) {
                        if (errStatus) {
                            binder.send(messages_1.prepareMessage({
                                type: registry[msg.type].replyError,
                                msgKey: msg.msgKey,
                                errStatus: errStatus
                            }), cb);
                        }
                        else {
                            binder.send(messages_1.prepareMessage({
                                type: registry[msg.type].replySuccess,
                                msgKey: msg.msgKey,
                                data: reply
                            }), cb);
                        }
                    });
                });
            }
            else {
                registry[msg.type].listener(msg.data, function (errStatus, reply) {
                    if (errStatus) {
                        binder.send(messages_1.prepareMessage({
                            type: registry[msg.type].replyError,
                            msgKey: msg.msgKey,
                            errStatus: errStatus
                        }));
                    }
                    else {
                        binder.send(messages_1.prepareMessage({
                            type: registry[msg.type].replySuccess,
                            msgKey: msg.msgKey,
                            data: reply
                        }));
                    }
                });
            }
        });
        callback(null, server);
    });
}
exports.initializeMessages = initializeMessages;
