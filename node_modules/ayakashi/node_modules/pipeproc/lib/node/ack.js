"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const transaction_1 = require("./transaction");
const d = debug_1.default("pipeproc:node");
function ack(db, activeProcs, procName, callback) {
    d("ack for proc:", procName);
    const myProc = activeProcs.find(p => p.name === procName);
    if (!myProc) {
        return callback(new Error("invalid_proc"));
    }
    d("acking:", myProc.lastClaimedRange);
    prepareAck(db, myProc).commitUpdate(function (err, lastAckedAt) {
        if (err) {
            callback(err);
        }
        else if (lastAckedAt) {
            myProc.lastAckedRange = myProc.lastClaimedRange;
            myProc.lastAckedAt = lastAckedAt;
            myProc.reclaims = 0;
            callback(null, myProc.lastAckedRange);
        }
        else {
            callback(new Error("ack_failed"));
        }
    });
}
exports.ack = ack;
function prepareAck(db, myProc) {
    const prefix = `~~system~~#proc#${myProc.topic}#${myProc.name}#`;
    const ackedTimestamp = Date.now();
    const tx = transaction_1.transaction(db);
    tx.add([{
            key: `${prefix}lastAckedRange`,
            value: `${myProc.lastClaimedRange}`
        }, {
            key: `${prefix}lastAckedAt`,
            value: `${ackedTimestamp}`
        }, {
            key: `${prefix}reclaims`,
            value: "0"
        }]);
    tx.done(function () {
        return ackedTimestamp;
    }, "ackTimestamps");
    return tx;
}
exports.prepareAck = prepareAck;
