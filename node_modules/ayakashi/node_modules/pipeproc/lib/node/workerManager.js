"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const forever_monitor_1 = require("forever-monitor");
const path_1 = require("path");
const async_1 = require("async");
const messages_1 = require("../common/messages");
const messaging_1 = require("./messaging");
const debug_1 = __importDefault(require("debug"));
const d = debug_1.default("pipeproc:node");
function spawnWorkers(workers, activeWorkers, activeProcs, activeSystemProcs, address, clientTLS, workerConcurrency, workerRestartAfter, callback) {
    if (!workers)
        return process.nextTick(callback);
    d("spawing workers...");
    async_1.timesSeries(workers, function (i, next) {
        d("workers:", i + 1, "/", workers);
        const monitor = new forever_monitor_1.Monitor(path_1.join(__dirname, "worker", "worker.js"), {
            //@ts-ignore
            fork: true,
            watch: false,
            args: ["--color"]
        });
        monitor.start();
        const worker = { process: monitor.child, monitor: monitor };
        function startWorker(restart) {
            async_1.series([
                function (cb) {
                    const msg = messages_1.prepareWorkerInitMessage(address, clientTLS, workerConcurrency, workerRestartAfter);
                    const listener = function (e) {
                        if (e.msgKey === msg.msgKey) {
                            worker.process.removeListener("message", listener);
                            if (e.type === "worker_connected") {
                                d("worker", worker.process.pid, "connected!");
                                if (!restart)
                                    activeWorkers.push(worker);
                                cb();
                            }
                            else {
                                cb(new Error(e.errStatus || "uknown_worker_spawn_error"));
                            }
                        }
                    };
                    worker.process.on("message", listener);
                    messaging_1.sendMessageToWorker(msg, worker);
                },
                function (cb) {
                    const msg = messages_1.prepareRegisterSystemProcsMessage(activeProcs.filter(p => activeSystemProcs.find(sp => sp.name === p.name)), activeSystemProcs);
                    const listener = function (e) {
                        if (e.msgKey === msg.msgKey) {
                            worker.process.removeListener("message", listener);
                            if (e.type === "register_system_proc_ok") {
                                cb();
                            }
                            else {
                                cb(new Error(e.errStatus || "register_system_proc_uknown_error"));
                            }
                        }
                    };
                    worker.process.on("message", listener);
                    messaging_1.sendMessageToWorker(msg, worker);
                }
            ], function (err) {
                if (err) {
                    d(err);
                }
                if (!restart) {
                    next(err);
                }
            });
        }
        startWorker(false);
        worker.monitor.on("restart", function () {
            worker.process = worker.monitor.child;
            d("restarting worker:", worker.process.pid);
            startWorker(true);
        });
    }, function (err) {
        if (err) {
            callback(err);
        }
        else {
            callback();
        }
    });
}
exports.spawnWorkers = spawnWorkers;
