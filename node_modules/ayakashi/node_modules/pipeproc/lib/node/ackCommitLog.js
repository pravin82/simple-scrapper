"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const commitLog_1 = require("./commitLog");
const ack_1 = require("./ack");
const transaction_1 = require("./transaction");
const d = debug_1.default("pipeproc:node");
function ackCommitLog(db, activeTopics, activeProcs, procName, log, callback) {
    d("ack for proc:", procName);
    const myProc = activeProcs.find(p => p.name === procName);
    if (!myProc) {
        return callback(new Error("invalid_proc"), ["", ""]);
    }
    const creationTime = Date.now();
    const tx = transaction_1.transaction(db);
    tx.add(ack_1.prepareAck(db, myProc));
    d("acking:", myProc.lastClaimedRange);
    d("new log(s):\n%O", log);
    if (Array.isArray(log)) {
        log.forEach(l => tx.add(commitLog_1.preCommit(db, activeTopics, l, creationTime)));
    }
    else {
        tx.add(commitLog_1.preCommit(db, activeTopics, log, creationTime));
    }
    tx.commitUpdate(function (err, lastAckedAt, commit) {
        if (err) {
            callback(err, ["", ""]);
        }
        else if (lastAckedAt && (typeof commit === "string" || (Array.isArray(commit) && commit.length > 0))) {
            myProc.lastAckedRange = myProc.lastClaimedRange;
            myProc.lastAckedAt = lastAckedAt;
            myProc.reclaims = 0;
            if (Array.isArray(log)) {
                callback(null, [myProc.lastAckedRange, commit]);
            }
            else {
                callback(null, [myProc.lastAckedRange, commit]);
            }
        }
        else {
            callback(null, ["", ""]);
        }
    });
}
exports.ackCommitLog = ackCommitLog;
