"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const async_1 = require("async");
const tones_1 = require("./tones");
const d = debug_1.default("pipeproc:node");
const VALID_RANGE_INPUT = /^(([0-9]*)|(:{0,1}[0-9]+)|([0-9]+-[0-9]+))$/;
function getRange(db, activeTopics, topic, start, end, limit, exclusive, reverse, callback) {
    if (!activeTopics[topic]) {
        return callback(new Error("invalid_topic"));
    }
    if (start) {
        if (!start.match(VALID_RANGE_INPUT)) {
            return callback(new Error("invalid_range_offset"));
        }
    }
    if (end) {
        if (!end.match(VALID_RANGE_INPUT)) {
            return callback(new Error("invalid_range_offset"));
        }
    }
    const prefix = `topic#${topic}#key#`;
    const sdo = { isStartIdSearch: false, isEndIdSearch: false, startId: "", endId: "" };
    const results = [];
    async_1.series([
        function (cb) {
            if (start.match(/:[0-9]+/)) {
                sdo.isStartIdSearch = true;
                let parsed = start.replace(":", "");
                parsed = tones_1.zeroPad(parsed);
                const idKey = `~~internal~~#topic#${topic}#idKey#${parsed}`;
                d("doing id search for start, idKey:", idKey);
                db.get(idKey, { asBuffer: false }, function (err, value) {
                    if (err && err.message.indexOf("NotFound") > -1) {
                        cb(new Error("invalid_tone_id_search"));
                    }
                    else if (err) {
                        cb(err);
                    }
                    else {
                        d("startKey:", value);
                        sdo.startId = value;
                        cb();
                    }
                });
            }
            else {
                cb();
            }
        },
        function (cb) {
            if (end.match(/:[0-9]+/)) {
                sdo.isEndIdSearch = true;
                let parsed = end.replace(":", "");
                parsed = tones_1.zeroPad(parsed);
                const idKey = `~~internal~~#topic#${topic}#idKey#${parsed}`;
                d("doing id search for end, idKey:", idKey);
                db.get(idKey, { asBuffer: false }, function (err, value) {
                    if (err && err.message.indexOf("NotFound") > -1) {
                        cb(new Error("invalid_tone_id_search"));
                    }
                    else if (err) {
                        cb(err);
                    }
                    else {
                        d("endKey:", value);
                        sdo.endId = value;
                        cb();
                    }
                });
            }
            else {
                cb();
            }
        },
        function (cb) {
            const iteratorOptions = getIteratorOptions(prefix, start, end, limit, reverse, exclusive, sdo);
            const iterator = db.iterator(iteratorOptions);
            async_1.forever(function (next) {
                iterator.next(function (err, key, value) {
                    if (err)
                        return next(err);
                    if (!key)
                        return next(new Error("stop"));
                    if (key.indexOf(prefix) > -1) {
                        results.push({ id: key.toString().split(prefix)[1], data: value.toString() });
                    }
                    async_1.setImmediate(next);
                });
            }, function (status) {
                if (!status || status.message === "stop") {
                    iterator.end(cb);
                }
                else {
                    cb(status);
                }
            });
        }
    ], function (err) {
        if (err) {
            callback(err);
        }
        else {
            d("range results: \n%O", results);
            callback(null, results);
        }
    });
}
exports.getRange = getRange;
function getIteratorOptions(prefix, start, end, limit, reverse, exclusive, sdo) {
    const iteratorOptions = {
        keyAsBuffer: false,
        valueAsBuffer: false,
        reverse: reverse
    };
    const comparator = { begin: "gte", end: "lte" };
    if (exclusive) {
        comparator.begin = "gt";
        comparator.end = "lt";
    }
    if (reverse) {
        if (sdo.isStartIdSearch) {
            iteratorOptions[comparator.end] = sdo.startId;
        }
        else {
            if (start && start.indexOf(":") === -1) {
                iteratorOptions[comparator.end] = prefix + start;
                if (!(iteratorOptions[comparator.end] || "").toString().match(/-.+|-[0-9]+/)) {
                    iteratorOptions[comparator.end] += "~";
                }
            }
            else {
                iteratorOptions[comparator.end] = `${prefix}~`;
            }
        }
        if (sdo.isEndIdSearch) {
            iteratorOptions[comparator.begin] = sdo.endId;
        }
        else {
            if (end && end.indexOf(":") === -1) {
                iteratorOptions[comparator.begin] = prefix + end;
            }
            else {
                iteratorOptions[comparator.begin] = `${prefix} `;
            }
        }
    }
    else {
        if (sdo.isStartIdSearch) {
            iteratorOptions[comparator.begin] = sdo.startId;
        }
        else {
            if (start && start.indexOf(":") === -1) {
                iteratorOptions[comparator.begin] = prefix + start;
            }
            else {
                iteratorOptions[comparator.begin] = `${prefix} `;
            }
        }
        if (sdo.isEndIdSearch) {
            iteratorOptions[comparator.end] = sdo.endId;
        }
        else {
            if (end && end.indexOf(":") === -1) {
                iteratorOptions[comparator.end] = prefix + end;
                if (!(iteratorOptions[comparator.end] || "").toString().match(/-.+|-[0-9]+/)) {
                    iteratorOptions[comparator.end] += "~";
                }
            }
            else {
                iteratorOptions[comparator.end] = `${prefix}~`;
            }
        }
    }
    if (limit && limit > 0) {
        iteratorOptions.limit = limit;
    }
    if (iteratorOptions.reverse) {
        d("iterating:", iteratorOptions[comparator.end], "=>", iteratorOptions[comparator.begin]);
    }
    else {
        d("iterating:", iteratorOptions[comparator.begin], "=>", iteratorOptions[comparator.end]);
    }
    return iteratorOptions;
}
