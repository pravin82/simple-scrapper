"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const browserify_1 = __importDefault(require("browserify"));
//@ts-ignore
const browserify_incremental_1 = __importDefault(require("browserify-incremental"));
const resolve_from_1 = __importDefault(require("resolve-from"));
const crypto_1 = require("crypto");
const path_1 = require("path");
const mkdirp_1 = require("mkdirp");
const debug_1 = __importDefault(require("debug"));
const d = debug_1.default("ayakashi:preloaderCompiler");
function compile(workingDir, entry, namespace, cacheFolder, useFileName, noCache) {
    if (!entry || (typeof entry !== "string" && typeof entry !== "function")) {
        return Promise.reject(new Error("invalid_compilation_target"));
    }
    if (!namespace || typeof namespace !== "string")
        return Promise.reject(new Error("invalid_namespace"));
    if ((!cacheFolder || typeof namespace !== "string") && !noCache)
        return Promise.reject(new Error("invalid_cache_folder"));
    const input = resolve_from_1.default.silent(workingDir, entry);
    if (!input)
        return Promise.reject(`Could not resolve module ${entry}`);
    const cacheFileName = crypto_1.createHash("sha1").update(input).digest("hex");
    let wrapperName;
    if (useFileName) {
        wrapperName = input.split(path_1.sep)[input.split(path_1.sep).length - 1];
        wrapperName = wrapperName.split(".")[0];
    }
    else {
        wrapperName = entry;
    }
    return new Promise(function (res, rej) {
        const b = browserify_1.default(Object.assign({}, JSON.parse(JSON.stringify(browserify_incremental_1.default.args)), { standalone: `${namespace}__${wrapperName}` }));
        if (noCache) {
            d("not using preloader cache");
        }
        else {
            mkdirp_1.sync(cacheFolder);
            browserify_incremental_1.default(b, { cacheFile: path_1.join(cacheFolder, `${cacheFileName}.json`) });
            b.once("time", function (ms) {
                d(`compiled ${input} in ${ms}ms with sha1 ${cacheFileName}`);
            });
        }
        b.add(input);
        b.bundle(function (err, buff) {
            if (err) {
                rej(err);
            }
            else {
                res({
                    wrapper: wrapperName,
                    source: buff.toString()
                });
            }
        })
            .once("error", function (err) {
            rej(err);
        });
    });
}
exports.compile = compile;
