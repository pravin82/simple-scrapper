"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
function default_1(ayakashiInstance) {
    ayakashiInstance.registerAction("wait", function (timeout = 1000) {
        return new Promise(function (resolve) {
            ayakashiInstance.__connection.timeouts.push(setTimeout(function () {
                resolve();
            }, timeout));
        });
    });
    ayakashiInstance.registerAction("waitUntil", function (cb, interval = 100, timeout = 2000) {
        if (typeof cb !== "function") {
            throw new Error("<waitUntil> needs a callback");
        }
        if (!interval || interval <= 0) {
            throw new Error("<waitUntil> needs a positive interval");
        }
        if (timeout < 0) {
            throw new Error("<waitUntil> needs a positive timeout");
        }
        return new Promise(function (resolve, reject) {
            let resolved = false;
            let aborted = false;
            const waiter = setInterval(function () {
                return __awaiter(this, void 0, void 0, function* () {
                    const cbResult = yield cb();
                    if (cbResult && !aborted) {
                        resolved = true;
                        clearInterval(waiter);
                        resolve(cbResult);
                    }
                });
            }, interval);
            if (timeout !== 0) {
                const timedOut = setTimeout(function () {
                    if (!resolved) {
                        aborted = true;
                        clearInterval(waiter);
                        reject(new Error(`<waitUntil> timed out after waiting ${timeout}ms`));
                    }
                }, timeout);
                ayakashiInstance.__connection.timeouts.push(timedOut);
            }
            ayakashiInstance.__connection.intervals.push(waiter);
        });
    });
    ayakashiInstance.registerAction("waitForInPageNavigation", function (timeout = 10000) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(function (resolve, reject) {
                let resolved = false;
                let aborted = false;
                const unsubscribe = ayakashiInstance.__connection.client.Page.navigatedWithinDocument(function () {
                    if (!aborted) {
                        resolved = true;
                        unsubscribe();
                        resolve();
                    }
                });
                if (timeout !== 0) {
                    const timedOut = setTimeout(function () {
                        if (!resolved) {
                            aborted = true;
                            unsubscribe();
                            reject(new Error(`<waitForInPageNavigation> timed out after waiting ${timeout}ms`));
                        }
                    }, timeout);
                    ayakashiInstance.__connection.timeouts.push(timedOut);
                }
                ayakashiInstance.__connection.unsubscribers.push(unsubscribe);
            });
        });
    });
    ayakashiInstance.registerAction("waitForLoadEvent", function (timeout = 10000) {
        return new Promise(function (resolve, reject) {
            let resolved = false;
            let aborted = false;
            const unsubscribe = ayakashiInstance.__connection.client.Page.loadEventFired(function () {
                if (!aborted) {
                    resolved = true;
                    unsubscribe();
                    resolve();
                }
            });
            if (timeout !== 0) {
                const timedOut = setTimeout(function () {
                    if (!resolved) {
                        aborted = true;
                        unsubscribe();
                        reject(new Error(`<waitForLoadEvent> timed out after waiting ${timeout}ms`));
                    }
                }, timeout);
                ayakashiInstance.__connection.timeouts.push(timedOut);
            }
            ayakashiInstance.__connection.unsubscribers.push(unsubscribe);
        });
    });
    ayakashiInstance.registerAction("waitForDomContentLoadedEvent", function (timeout = 10000) {
        return new Promise(function (resolve, reject) {
            let resolved = false;
            let aborted = false;
            const unsubscribe = ayakashiInstance.__connection.client.Page.domContentEventFired(function () {
                if (!aborted) {
                    resolved = true;
                    unsubscribe();
                    resolve();
                }
            });
            if (timeout !== 0) {
                const timedOut = setTimeout(function () {
                    if (!resolved) {
                        aborted = true;
                        unsubscribe();
                        reject(new Error(`<waitForDomContentLoadedEvent> timed out after waiting ${timeout}ms`));
                    }
                }, timeout);
                ayakashiInstance.__connection.timeouts.push(timedOut);
            }
            ayakashiInstance.__connection.unsubscribers.push(unsubscribe);
        });
    });
    ayakashiInstance.registerAction("waitUntilExists", function (prop, timeout = 10000) {
        return __awaiter(this, void 0, void 0, function* () {
            const myProp = this.prop(prop);
            if (!myProp) {
                throw new Error("<waitUntilExists> needs a valid prop");
            }
            return ayakashiInstance.waitUntil(function () {
                return __awaiter(this, void 0, void 0, function* () {
                    const matchCount = yield myProp.trigger({ force: true, showNoMatchesWarning: false });
                    return matchCount > 0;
                });
            }, 100, timeout);
        });
    });
    ayakashiInstance.registerAction("waitUntilVisible", function (prop, timeout = 10000) {
        return __awaiter(this, void 0, void 0, function* () {
            const myProp = this.prop(prop);
            if (!myProp) {
                throw new Error("<waitUntilVisible> needs a valid prop");
            }
            yield this.waitUntilExists(myProp, timeout);
            return ayakashiInstance.waitUntil(function () {
                return __awaiter(this, void 0, void 0, function* () {
                    return ayakashiInstance.evaluate(function (scopedPropId) {
                        const node = this.propTable[scopedPropId].matches[0];
                        return !!(node.offsetWidth || node.offsetHeight || node.getClientRects().length);
                    }, myProp.id);
                });
            }, 100, timeout);
        });
    });
}
exports.default = default_1;
